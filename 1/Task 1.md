## Задание 1
Перечислите все проблемы, которые вы видите в данном коде:


    class Foo
    {
    public:
        Foo(int j) { i=new int[j]; }
        ~Foo() { delete i; }
    private:
        int* i;
    };
    
    class Bar: Foo
    {
    public:
        Bar(int j) { i=new char[j]; }
        ~Bar() { delete i; }
    private:
        char* i;
    };
    
    void main()
    {
        Foo* f=new Foo(100);
        Foo* b=new Bar(200);
        *f=*b;
        delete f;
        delete b;
    }
---
1) Отсутствует проверка того, выделилась ли память операторами `new` 
2) Перед освобождением памяти нет проверки валидности указателя 
3) Из-за строки `*f=*b;` деструктор будет вызван дважды для одного и того же объекта. Следовательно будет утечка памяти 
(в `f`) и повторное освобождение памяти (в `b`). И если первое опасно, то второе - фатально. 
4) Нет проверок на корректность входных данных(например, размер массива должен быть неотрицательным). 
5) Для освобождения памяти под динамический массив следует использовать `delete[]`, а не `delete`. С `int*`, скорее всего, 
проблем не возникнет, но "неопределённого поведения" следует избегать. 
6) При создании экземпляра класса `Bar` создаётся его предок `Foo`, однако не передан аргумент конструктора предка, а 
конструктора по умолчания у класса `Foo` нет. 
7) Из-за строки `Foo* b = new Bar(200);` наследование должно быть публичным: `class Bar: public Foo {...}`. 
Если ничего не указано, то "почти наверное" будет подставлено `private`. И компилятор сообщит о том, что данное 
преобразование существует но не доступно
8) Т.к. деструктор класса `Bar` не виртуальный, то в строке `delete b` будет вызван только деструктор класса `Foo` (т.к. `Foo* b;`), 
следовательно утечка памяти. 
9) Имена переменных: 
* название переменных должно отражать их смысл 
* имена `i, j` - классически используются как переменные цикла, что может случайно привести к конфликту имён. 
* скорее всего подразумевалось, что класс `Bar` имеет переменную типа `char*` и работает с данным типом вместо `int*`. 
Однако на самом деле он хранит `int* i;` в своём предке и `char* i;` в себе. Это разные переменные 
(одно название, разное пространство имён)