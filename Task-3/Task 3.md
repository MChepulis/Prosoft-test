## Задание 3  
Все ли хорошо в этом коде?

##### Файл legacy.c
    
    int values[3];
    
##### Файл modern.cpp
    
    #define LEGACY_SIZE 3
    extern int *values;
    
    class MyBlah {...};
    
    class Adapter
    {
        public:
        Adapter()
        {
            for (int i = 0; i < LEGACY_SIZE; ++i)
            map_[values[i]] = new MyBlah (values[i]);
        }
    private:
        std::map<int, MyBlah *> map_;
    };   
---
1) Файл `legacy.c` не подключён к файлу modern.cpp 
2) Чтобы типы косвенного обращения не различались должно быть: `extern int values[LEGACY_SIZE]`. т.к. иначе 
это просто указатель, а не буфер на `LEGACY_SIZE` элементов. 
3) Макрос `#define LEGACY_SIZE 3` изначально должен был находиться в файле `legacy.c`. Т.к. очень плохо предполагать 
извне что-то о размерах переменных. 
4) И в строке `int values[3];` следовало тоже использовать подстановку: `int values[LEGACY_SIZE];` 
5) Нет проверки результатов выделения памяти. 
6) Так как указатель на выделенную память записывается сразу в строку `map`, то есть вероятность того, что новое значение 
перезапишет уже лежащий там указатель (при совпадении значений в `value`). В таком случае произойдёт утечка памяти. 
7) У класса `Adapter` отсутствует явный деструктор, следовательно будет создан конструктор по умолчания. Из-за этого не 
будет освобождена память, выделенная при `... = new MyBlah(...)`, а следовательно произойдёт утечка памяти. 
8) Переменная цикла `int i` знаковая, но используется как беззнаковый индекс. 
